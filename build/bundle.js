(()=>{"use strict";new Set;const e="undefined"!=typeof window?window:"undefined"!=typeof globalThis?globalThis:global;class t{_listeners="WeakMap"in e?new WeakMap:void 0;_observer=void 0;options;constructor(e){this.options=e}observe(e,t){return this._listeners.set(e,t),this._getObserver().observe(e,this.options),()=>{this._listeners.delete(e),this._observer.unobserve(e)}}_getObserver(){return this._observer??(this._observer=new ResizeObserver((e=>{for(const n of e)t.entries.set(n.target,n),this._listeners.get(n.target)?.(n)})))}}t.entries="WeakMap"in e?new WeakMap:void 0;let n,o,r=!1;function i(e,t){e.appendChild(t)}function s(e,t,n){const o=function(e){if(!e)return document;const t=e.getRootNode?e.getRootNode():e.ownerDocument;return t&&t.host?t:e.ownerDocument}(e);if(!o.getElementById(t)){const e=c("style");e.id=t,e.textContent=n,function(e,t){i(e.head||e,t),t.sheet}(o,e)}}function a(e,t,n){e.insertBefore(t,n||null)}function l(e){e.parentNode&&e.parentNode.removeChild(e)}function c(e){return document.createElement(e)}function d(e){return document.createTextNode(e)}function h(){return d(" ")}function u(e,t,n){null==n?e.removeAttribute(t):e.getAttribute(t)!==n&&e.setAttribute(t,n)}function p(e,t,{bubbles:n=!1,cancelable:o=!1}={}){return new CustomEvent(e,{detail:t,bubbles:n,cancelable:o})}class f{is_svg=!1;e=void 0;n=void 0;t=void 0;a=void 0;constructor(e=!1){this.is_svg=e,this.e=this.n=null}c(e){this.h(e)}m(e,t,n=null){var o;this.e||(this.is_svg?this.e=(o=t.nodeName,document.createElementNS("http://www.w3.org/2000/svg",o)):this.e=c(11===t.nodeType?"TEMPLATE":t.nodeName),this.t="TEMPLATE"!==t.tagName?t:t.content,this.c(e)),this.i(n)}h(e){this.e.innerHTML=e,this.n=Array.from("TEMPLATE"===this.e.nodeName?this.e.content.childNodes:this.e.childNodes)}i(e){for(let t=0;t<this.n.length;t+=1)a(this.t,this.n[t],e)}p(e){this.d(),this.h(e),this.i(this.a)}d(){this.n.forEach(l)}}function m(){}function $(e,t,n,o,r){e.__svelte_meta={loc:{file:t,line:n,column:o,char:r}}}function A(e){return e()}function g(){return Object.create(null)}function w(e){e.forEach(A)}function y(e){return"function"==typeof e}function b(e,t){return e!=e?t==t:e!==t||e&&"object"==typeof e||"function"==typeof e}function v(e,t){return e===t||(n||(n=document.createElement("a")),n.href=t,e===n.href)}function E(e){o=e}function Q(){if(!o)throw new Error("Function called outside component initialization");return o}function x(e){Q().$$.on_mount.push(e)}function P(e){Q().$$.on_destroy.push(e)}function k(){const e=Q();return(t,n,{cancelable:o=!1}={})=>{const r=e.$$.callbacks[t];if(r){const i=p(t,n,{cancelable:o});return r.slice().forEach((t=>{t.call(e,i)})),!i.defaultPrevented}return!0}}new Map;const C=[],N=[];let D=[];const L=[],R=Promise.resolve();let _=!1;function j(e){D.push(e)}function S(e){L.push(e)}const F=new Set;let I=0;function U(){if(0!==I)return;const e=o;do{try{for(;I<C.length;){const e=C[I];I++,E(e),B(e.$$)}}catch(e){throw C.length=0,I=0,e}for(E(null),C.length=0,I=0;N.length;)N.pop()();for(let e=0;e<D.length;e+=1){const t=D[e];F.has(t)||(F.add(t),t())}D.length=0}while(C.length);for(;L.length;)L.pop()();_=!1,F.clear(),E(e)}function B(e){if(null!==e.fragment){e.update(),w(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(j)}}const T=new Set;let W,M;function O(e,t){e&&e.i&&(T.delete(e),e.i(t))}function J(e,t,n,o){if(e&&e.o){if(T.has(e))return;T.add(e),W.c.push((()=>{T.delete(e),o&&(n&&e.d(1),o())})),e.o(t)}else o&&o()}function Z(e,t,n){const o=e.$$.props[t];void 0!==o&&(e.$$.bound[o]=n,n(e.$$.ctx[o]))}function z(e){e&&e.c()}function X(e,t,n){const{fragment:o,after_update:r}=e.$$;o&&o.m(t,n),j((()=>{const t=e.$$.on_mount.map(A).filter(y);e.$$.on_destroy?e.$$.on_destroy.push(...t):w(t),e.$$.on_mount=[]})),r.forEach(j)}function Y(e,t){const n=e.$$;null!==n.fragment&&(function(e){const t=[],n=[];D.forEach((o=>-1===e.indexOf(o)?t.push(o):n.push(o))),n.forEach((e=>e())),D=t}(n.after_update),w(n.on_destroy),n.fragment&&n.fragment.d(t),n.on_destroy=n.fragment=null,n.ctx=[])}function V(e,t,n,i,s,a,c=null,d=[-1]){const h=o;E(e);const u=e.$$={fragment:null,ctx:[],props:a,update:m,not_equal:s,bound:g(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(t.context||(h?h.$$.context:[])),callbacks:g(),dirty:d,skip_bound:!1,root:t.target||h.$$.root};c&&c(u.root);let p=!1;if(u.ctx=n?n(e,t.props||{},((t,n,...o)=>{const r=o.length?o[0]:n;return u.ctx&&s(u.ctx[t],u.ctx[t]=r)&&(!u.skip_bound&&u.bound[t]&&u.bound[t](r),p&&function(e,t){-1===e.$$.dirty[0]&&(C.push(e),_||(_=!0,R.then(U)),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}(e,t)),n})):[],u.update(),p=!0,w(u.before_update),u.fragment=!!i&&i(u.ctx),t.target){if(t.hydrate){r=!0;const e=(f=t.target,Array.from(f.childNodes));u.fragment&&u.fragment.l(e),e.forEach(l)}else u.fragment&&u.fragment.c();t.intro&&O(e.$$.fragment),X(e,t.target,t.anchor),r=!1,U()}var f;E(h)}function q(e,t,n,o){const r=n[e]?.type;if(t="Boolean"===r&&"boolean"!=typeof t?null!=t:t,!o||!n[e])return t;if("toAttribute"===o)switch(r){case"Object":case"Array":return null==t?null:JSON.stringify(t);case"Boolean":return t?"":null;case"Number":return null==t?null:t;default:return t}else switch(r){case"Object":case"Array":return t&&JSON.parse(t);case"Boolean":default:return t;case"Number":return null!=t?+t:t}}new Set(["allowfullscreen","allowpaymentrequest","async","autofocus","autoplay","checked","controls","default","defer","disabled","formnovalidate","hidden","inert","ismap","loop","multiple","muted","nomodule","novalidate","open","playsinline","readonly","required","reversed","selected"]),"function"==typeof HTMLElement&&(M=class extends HTMLElement{$$ctor;$$s;$$c;$$cn=!1;$$d={};$$r=!1;$$p_d={};$$l={};$$l_u=new Map;constructor(e,t,n){super(),this.$$ctor=e,this.$$s=t,n&&this.attachShadow({mode:"open"})}addEventListener(e,t,n){if(this.$$l[e]=this.$$l[e]||[],this.$$l[e].push(t),this.$$c){const n=this.$$c.$on(e,t);this.$$l_u.set(t,n)}super.addEventListener(e,t,n)}removeEventListener(e,t,n){if(super.removeEventListener(e,t,n),this.$$c){const e=this.$$l_u.get(t);e&&(e(),this.$$l_u.delete(t))}}async connectedCallback(){if(this.$$cn=!0,!this.$$c){if(await Promise.resolve(),!this.$$cn)return;function e(e){return()=>{let t;return{c:function(){t=c("slot"),"default"!==e&&u(t,"name",e)},m:function(e,n){a(e,t,n)},d:function(e){e&&l(t)}}}}const t={},n=function(e){const t={};return e.childNodes.forEach((e=>{t[e.slot||"default"]=!0})),t}(this);for(const r of this.$$s)r in n&&(t[r]=[e(r)]);for(const i of this.attributes){const s=this.$$g_p(i.name);s in this.$$d||(this.$$d[s]=q(s,i.value,this.$$p_d,"toProp"))}this.$$c=new this.$$ctor({target:this.shadowRoot||this,props:{...this.$$d,$$slots:t,$$scope:{ctx:[]}}});const o=()=>{this.$$r=!0;for(const e in this.$$p_d)if(this.$$d[e]=this.$$c.$$.ctx[this.$$c.$$.props[e]],this.$$p_d[e].reflect){const t=q(e,this.$$d[e],this.$$p_d,"toAttribute");null==t?this.removeAttribute(this.$$p_d[e].attribute||e):this.setAttribute(this.$$p_d[e].attribute||e,t)}this.$$r=!1};this.$$c.$$.after_update.push(o),o();for(const d in this.$$l)for(const h of this.$$l[d]){const p=this.$$c.$on(d,h);this.$$l_u.set(h,p)}this.$$l={}}}attributeChangedCallback(e,t,n){this.$$r||(e=this.$$g_p(e),this.$$d[e]=q(e,n,this.$$p_d,"toProp"),this.$$c?.$set({[e]:this.$$d[e]}))}disconnectedCallback(){this.$$cn=!1,Promise.resolve().then((()=>{this.$$cn||(this.$$c.$destroy(),this.$$c=void 0)}))}$$g_p(e){return Object.keys(this.$$p_d).find((t=>this.$$p_d[t].attribute===e||!this.$$p_d[t].attribute&&t.toLowerCase()===e))||e}});class G{$$=void 0;$$set=void 0;$destroy(){Y(this,1),this.$destroy=m}$on(e,t){if(!y(t))return m;const n=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return n.push(t),()=>{const e=n.indexOf(t);-1!==e&&n.splice(e,1)}}$set(e){var t;this.$$set&&(t=e,0!==Object.keys(t).length)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}const H="4.2.2";function K(e,t){document.dispatchEvent(p(e,{version:H,...t},{bubbles:!0}))}function ee(e,t){K("SvelteDOMInsert",{target:e,node:t}),i(e,t)}function te(e,t,n){K("SvelteDOMInsert",{target:e,node:t,anchor:n}),a(e,t,n)}function ne(e){K("SvelteDOMRemove",{node:e}),l(e)}function oe(e,t,n,o,r,i,s){const a=!0===o?["capture"]:o?Array.from(Object.keys(o)):[];r&&a.push("preventDefault"),i&&a.push("stopPropagation"),s&&a.push("stopImmediatePropagation"),K("SvelteDOMAddEventListener",{node:e,event:t,handler:n,modifiers:a});const l=function(e,t,n,o){return e.addEventListener(t,n,o),()=>e.removeEventListener(t,n,o)}(e,t,n,o);return()=>{K("SvelteDOMRemoveEventListener",{node:e,event:t,handler:n,modifiers:a}),l()}}function re(e,t,n){u(e,t,n),null==n?K("SvelteDOMRemoveAttribute",{node:e,attribute:t}):K("SvelteDOMSetAttribute",{node:e,attribute:t,value:n})}function ie(e,t,n){for(const o of Object.keys(t))~n.indexOf(o)||console.warn(`<${e}> received an unexpected slot "${o}".`)}class se extends G{$$prop_def;$$events_def;$$slot_def;constructor(e){if(!e||!e.target&&!e.$$inline)throw new Error("'target' is a required option");super()}$destroy(){super.$destroy(),this.$destroy=()=>{console.warn("Component was already destroyed")}}$capture_state(){}$inject_state(){}}"undefined"!=typeof window&&(window.__svelte||(window.__svelte={v:new Set})).v.add("4");const ae="src/Swap.svelte";function le(e){let t,n,o,r,i;const s={c:function(){t=c("main"),n=c("div"),o=new f(!1),r=h(),i=c("div"),i.innerHTML="",o.a=r,$(i,ae,74,4,2356),$(n,ae,72,4,2323),$(t,ae,71,0,2312)},l:function(e){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(s,a){te(s,t,a),ee(t,n),o.m(e[0],n),ee(n,r),ee(n,i)},p:function(e,[t]){1&t&&o.p(e[0])},i:m,o:m,d:function(e){e&&ne(t)}};return K("SvelteRegisterBlock",{block:s,id:le.name,type:"component",source:"",ctx:e}),s}function ce(e,t,n){let{$$slots:o={},$$scope:r}=t;ie("Swap",o,[]);let{samp:i="\n    \\infer{\\land}{E}{\n            A\n            &\n            \\infer{\\lor}{D}{B & C}\n        }\n    "}=t;const s={splitr:"&",splitrRep:"\\qquad ",labelMark:"=",escapeChar:"+",singleVarRep:"\\lower5pt",entail:"*",entailRep:"\\vdots"};let a="CONTENTS NOT LOADED";x((()=>{let e=[];function t(e,t){for(let n=0;n<t.length;n++)e.push(t.charAt(n));return e}for(let n=0;n<i.length;n++){let o=i.charAt(n);if(o==s.splitr)e=t(e,s.splitrRep);else if(o==s.escapeChar);else if(o==s.entail){let o=[];for(let e=n;e<i.length;e++)if("{"==i.charAt(e)&&(o[0]=e),"}"==i.charAt(e)){o[1]=e;break}e=t(e,i.substring(o[0],o[1]-1)),e=t(e,s.entailRep+"}"),n=n+s.entailRep.length+o[1]-o[0]}else if(o==s.labelMark&&i.charAt(n-1)!=s.escapeChar){let o=[];for(let e=n;e<i.length;e++)"["!=i.charAt(e)&&"]"!=i.charAt(e)||o.push(e);const r="{"+i.substring(o[0]+1,o[1]-2)+"}";e=t(e,r),n=n+r.length+2}else e.push(i.charAt(n))}n(0,a=e.join(""))}));const l=["samp"];return Object.keys(t).forEach((e=>{~l.indexOf(e)||"$$"===e.slice(0,2)||"slot"===e||console.warn(`<Swap> was created with unknown prop '${e}'`)})),e.$$set=e=>{"samp"in e&&n(1,i=e.samp)},e.$capture_state=()=>({createEventDispatcher:k,onMount:x,samp:i,map:s,output:a}),e.$inject_state=e=>{"samp"in e&&n(1,i=e.samp),"output"in e&&n(0,a=e.output)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),[a,i]}const de=class extends se{constructor(e){super(e),V(this,e,ce,le,b,{samp:1}),K("SvelteRegisterComponent",{component:this,tagName:"Swap",options:e,id:le.name})}get samp(){throw new Error("<Swap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set samp(e){throw new Error("<Swap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}},{console:he}=e;function ue(e){const t={c:m,l:function(e){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m,p:m,i:m,o:m,d:m};return K("SvelteRegisterBlock",{block:t,id:ue.name,type:"component",source:"",ctx:e}),t}const pe="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js";function fe(e,t,n){let{$$slots:o={},$$scope:r}=t;ie("MathJax",o,[]),x((()=>{let e=document.createElement("script");e.src=pe,e.onload=()=>{console.log("MathJax Loaded"),MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}},console.log("Here"),document.head.append(e)})),P((()=>{let e=document.head.getElementsByTagName("script");for(const t of e)t.getAttribute("src")==pe&&t.remove()}));const i=[];return Object.keys(t).forEach((e=>{~i.indexOf(e)||"$$"===e.slice(0,2)||"slot"===e||he.warn(`<MathJax> was created with unknown prop '${e}'`)})),e.$capture_state=()=>({mjsource:pe,createEventDispatcher:k,onDestroy:P,onMount:x}),[]}const me=class extends se{constructor(e){super(e),V(this,e,fe,ue,b,{}),K("SvelteRegisterComponent",{component:this,tagName:"MathJax_1",options:e,id:ue.name})}},{console:$e}=e;function Ae(e){s(e,"svelte-s9kwgq","div.svelte-s9kwgq{background-color:#ffffff;color:rgb(54, 54, 54)}.document.svelte-s9kwgq{border-width:5px;border-color:black;text-align:center;position:relative;left:15vw;width:52vw;overflow:scroll}.svelte-s9kwgq::-webkit-scrollbar{display:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG9jdW1lbnQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXNCSSxrQkFDSSx3QkFBeUIsQ0FDekIscUJBQ0osQ0FTQSx3QkFDSSxnQkFBZ0IsQ0FDaEIsa0JBQWtCLENBQ2xCLGlCQUFrQixDQUNsQixpQkFBaUIsQ0FDakIsU0FBUyxDQUNULFVBQVcsQ0FDWCxlQUNKLGVBRUEsb0JBQ0ksWUFDSiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJEb2N1bWVudC5zdmVsdGUiXX0= */")}function ge(e){let t,n,o,r,i,s,a;n=new me({$$inline:!0}),s=new de({props:{samp:e[0]},$$inline:!0});const l={c:function(){t=c("div"),z(n.$$.fragment),o=d("\n    \\("),r=d("\\newcommand{\\infer}[3]{\\cfrac{#3}{#2}\\small{#1}}"),i=d("\\)\n        "),z(s.$$.fragment),re(t,"class","document svelte-s9kwgq"),$(t,"src/Document.svelte",15,0,963)},l:function(e){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(e,l){te(e,t,l),X(n,t,null),ee(t,o),ee(t,r),ee(t,i),X(s,t,null),a=!0},p:function(e,[t]){const n={};1&t&&(n.samp=e[0]),s.$set(n)},i:function(e){a||(O(n.$$.fragment,e),O(s.$$.fragment,e),a=!0)},o:function(e){J(n.$$.fragment,e),J(s.$$.fragment,e),a=!1},d:function(e){e&&ne(t),Y(n),Y(s)}};return K("SvelteRegisterBlock",{block:l,id:ge.name,type:"component",source:"",ctx:e}),l}function we(e,t,n){let{$$slots:o={},$$scope:r}=t;ie("Document",o,[]);var i=this&&this.__awaiter||function(e,t,n,o){return new(n||(n=Promise))((function(r,i){function s(e){try{l(o.next(e))}catch(e){i(e)}}function a(e){try{l(o.throw(e))}catch(e){i(e)}}function l(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}l((o=o.apply(e,t||[])).next())}))};let{ref:s}=t,{page:a}=t;console.log(a);const l=()=>i(void 0,void 0,void 0,(function*(){return a}));e.$$.on_mount.push((function(){void 0!==s||"ref"in t||e.$$.bound[e.$$.props.ref]||$e.warn("<Document> was created without expected prop 'ref'"),void 0!==a||"page"in t||e.$$.bound[e.$$.props.page]||$e.warn("<Document> was created without expected prop 'page'")}));const c=["ref","page"];return Object.keys(t).forEach((e=>{~c.indexOf(e)||"$$"===e.slice(0,2)||"slot"===e||$e.warn(`<Document> was created with unknown prop '${e}'`)})),e.$$set=e=>{"ref"in e&&n(1,s=e.ref),"page"in e&&n(0,a=e.page)},e.$capture_state=()=>({__awaiter:i,Swap:de,MathJax:me,ref:s,page:a,load:l}),e.$inject_state=e=>{"__awaiter"in e&&(i=e.__awaiter),"ref"in e&&n(1,s=e.ref),"page"in e&&n(0,a=e.page)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),[a,s,l]}const ye=class extends se{constructor(e){super(e),V(this,e,we,ge,b,{ref:1,page:0,load:2},Ae),K("SvelteRegisterComponent",{component:this,tagName:"Document",options:e,id:ge.name})}get ref(){throw new Error("<Document>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set ref(e){throw new Error("<Document>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get page(){throw new Error("<Document>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set page(e){throw new Error("<Document>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get load(){return this.$$.ctx[2]}set load(e){throw new Error("<Document>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}},{console:be}=e,ve="src/Sidebar.svelte";function Ee(e){s(e,"svelte-k3vjgv",".sidebar.svelte-k3vjgv{position:fixed;width:14vw;left:0;border-color:#000000;background:white;border-right:2px solid #000000;color:rgb(13, 13, 13);transition:all ease .3s;text-align:center;overflow:scroll}.sidebar-title.svelte-k3vjgv{color:black;font-size:medium;text-align:center;margin-left:5px;border-top:1px solid hsl(0, 0%, 60%);border-bottom:1px solid hsl(0, 0%, 60%)}.sidebar-subtitle.svelte-k3vjgv{color:black;font-size:medium;text-align:center;margin-left:5px;border-bottom:1px solid hsl(0, 0%, 60%)}.links_to_pages.svelte-k3vjgv{color:black;text-align:left;font-size:medium;margin-right:10px;text-decoration:none;outline:0;&:hover{\n      text-decoration: none;\n    }}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2lkZWJhci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBb0RFLHVCQUNFLGNBQWUsQ0FDZixVQUFXLENBQ1gsTUFBTyxDQUNQLG9CQUFxQixDQUNyQixnQkFBaUIsQ0FDakIsOEJBQStCLENBRS9CLHFCQUFzQixDQUN0Qix1QkFBd0IsQ0FDeEIsaUJBQWtCLENBQ2xCLGVBQ0YsQ0FHQSw2QkFDSSxXQUFXLENBQ1gsZ0JBQWdCLENBQ2hCLGlCQUFpQixDQUNqQixlQUFnQixDQUNoQixvQ0FBb0MsQ0FDcEMsdUNBRUosQ0FFQSxnQ0FDSSxXQUFXLENBQ1gsZ0JBQWdCLENBQ2hCLGlCQUFpQixDQUNqQixlQUFnQixDQUNoQix1Q0FFSixDQUNBLDhCQUNFLFdBQVksQ0FDWixlQUFnQixDQUNoQixnQkFBZ0IsQ0FDaEIsaUJBQWtCLENBQ2xCLG9CQUFxQixDQUNyQixTQUFVLENBQ1Y7TUFDRSxxQkFBcUI7S0FFekIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU2lkZWJhci5zdmVsdGUiXX0= */")}function Qe(e){let t,n,o,r,i,s,a,l,d,u,p,f,A,g,y,b,v,E,Q,x,P,k,C,N,D,L,R,_,j,S,F,I;const U={c:function(){t=c("div"),n=c("div"),o=c("div"),r=c("ul"),i=c("button"),i.textContent="Welcome",s=h(),a=c("h5"),a.textContent="Propositional Logic",l=h(),d=c("ul"),u=c("button"),u.textContent="LEAN syntax",p=h(),f=c("ul"),A=c("button"),A.textContent="Semantics",g=h(),y=c("h5"),y.textContent="Natural deduction",b=h(),v=c("ul"),E=c("button"),E.textContent="Conjunction",Q=h(),x=c("ul"),P=c("button"),P.textContent="Conditional",k=h(),C=c("ul"),N=c("button"),N.textContent="Disjunction",D=h(),L=c("ul"),R=c("button"),R.textContent="Negation",_=h(),j=c("ul"),S=c("button"),S.textContent="Combined Rules",$(i,ve,20,10,408),$(r,ve,19,8,393),re(a,"class","sidebar-title svelte-k3vjgv"),$(a,ve,22,8,489),$(u,ve,24,10,565),$(d,ve,23,8,550),$(A,ve,27,10,664),$(f,ve,26,8,649),re(y,"class","sidebar-subtitle svelte-k3vjgv"),$(y,ve,29,8,749),$(E,ve,31,10,826),$(v,ve,30,8,811),$(P,ve,34,10,930),$(x,ve,33,8,915),$(N,ve,37,10,1035),$(C,ve,36,8,1020),$(R,ve,40,9,1139),$(L,ve,39,8,1125),$(S,ve,43,10,1238),$(j,ve,42,8,1223),re(o,"class","links_to_pages svelte-k3vjgv"),$(o,ve,18,6,354),$(n,ve,17,2,342),re(t,"class","sidebar svelte-k3vjgv"),$(t,ve,14,0,295)},l:function(e){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(c,h){te(c,t,h),ee(t,n),ee(n,o),ee(o,r),ee(r,i),ee(o,s),ee(o,a),ee(o,l),ee(o,d),ee(d,u),ee(o,p),ee(o,f),ee(f,A),ee(o,g),ee(o,y),ee(o,b),ee(o,v),ee(v,E),ee(o,Q),ee(o,x),ee(x,P),ee(o,k),ee(o,C),ee(C,N),ee(o,D),ee(o,L),ee(L,R),ee(o,_),ee(o,j),ee(j,S),F||(I=[oe(i,"click",e[1],!1,!1,!1,!1),oe(u,"click",e[2],!1,!1,!1,!1),oe(A,"click",e[3],!1,!1,!1,!1),oe(E,"click",e[4],!1,!1,!1,!1),oe(P,"click",e[5],!1,!1,!1,!1),oe(N,"click",e[6],!1,!1,!1,!1),oe(R,"click",e[7],!1,!1,!1,!1),oe(S,"click",e[8],!1,!1,!1,!1)],F=!0)},p:m,i:m,o:m,d:function(e){e&&ne(t),F=!1,w(I)}};return K("SvelteRegisterBlock",{block:U,id:Qe.name,type:"component",source:"",ctx:e}),U}function xe(e,t,n){let{$$slots:o={},$$scope:r}=t;ie("Sidebar",o,[]);const i=k();function s(e){console.log("emitting event, button pressed: "+e),i("documentSelection",{document:e})}const a=[];return Object.keys(t).forEach((e=>{~a.indexOf(e)||"$$"===e.slice(0,2)||"slot"===e||be.warn(`<Sidebar> was created with unknown prop '${e}'`)})),e.$capture_state=()=>({createEventDispatcher:k,dispatch:i,event:s}),[s,()=>s("Welcome"),()=>s("Syntax"),()=>s("Semantics"),()=>s("Conjunction"),()=>s("Conditional"),()=>s("Disjunction"),()=>s("Negation"),()=>s("CombinedRules")]}const Pe=class extends se{constructor(e){super(e),V(this,e,xe,Qe,b,{},Ee),K("SvelteRegisterComponent",{component:this,tagName:"Sidebar",options:e,id:Qe.name})}},{console:ke}=e,Ce="src/IFrameEditor.svelte";function Ne(e){s(e,"svelte-1gzhtlv","iframe.svelte-1gzhtlv{position:fixed;overflow:hidden;flex:0.8 0 0px;right:0;top:0;height:100vh;width:30vw}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSUZyYW1lRWRpdG9yLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFZSSxzQkFDSSxjQUFlLENBQ2YsZUFBZ0IsQ0FDaEIsY0FBZSxDQUNmLE9BQVEsQ0FDUixLQUFNLENBQ04sWUFBYSxDQUNiLFVBQ0oiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSUZyYW1lRWRpdG9yLnN2ZWx0ZSJdfQ== */")}function De(e){let t,n;const o={c:function(){t=c("iframe"),v(t.src,n=e[0])||re(t,"src",n),re(t,"width","300"),re(t,"height","100vh"),re(t,"class","svelte-1gzhtlv"),$(t,Ce,8,12,180)},m:function(n,o){te(n,t,o),e[2](t)},p:function(e,o){1&o&&!v(t.src,n=e[0])&&re(t,"src",n)},d:function(n){n&&ne(t),e[2](null)}};return K("SvelteRegisterBlock",{block:o,id:De.name,type:"key",source:"(7:8) {#key editorUrl}",ctx:e}),o}function Le(e){let t,n=e[0],o=De(e);const r={c:function(){o.c(),t=d("")},l:function(e){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(e,n){o.m(e,n),te(e,t,n)},p:function(e,[r]){1&r&&b(n,n=e[0])?(o.d(1),o=De(e),o.c(),o.m(t.parentNode,t)):o.p(e,r)},i:m,o:m,d:function(e){e&&ne(t),o.d(e)}};return K("SvelteRegisterBlock",{block:r,id:Le.name,type:"component",source:"",ctx:e}),r}function Re(e,t,n){let{$$slots:o={},$$scope:r}=t;ie("IFrameEditor",o,[]);let i,{editorUrl:s}=t,a=!0;console.log(s),e.$$.on_mount.push((function(){void 0!==s||"editorUrl"in t||e.$$.bound[e.$$.props.editorUrl]||ke.warn("<IFrameEditor> was created without expected prop 'editorUrl'")}));const l=["editorUrl"];return Object.keys(t).forEach((e=>{~l.indexOf(e)||"$$"===e.slice(0,2)||"slot"===e||ke.warn(`<IFrameEditor> was created with unknown prop '${e}'`)})),e.$$set=e=>{"editorUrl"in e&&n(0,s=e.editorUrl)},e.$capture_state=()=>({onMount:x,editorUrl:s,frame:i,frameActive:a}),e.$inject_state=e=>{"editorUrl"in e&&n(0,s=e.editorUrl),"frame"in e&&n(1,i=e.frame),"frameActive"in e&&(a=e.frameActive)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),[s,i,function(e){N[e?"unshift":"push"]((()=>{i=e,n(1,i)}))}]}const _e=class extends se{constructor(e){super(e),V(this,e,Re,Le,b,{editorUrl:0},Ne),K("SvelteRegisterComponent",{component:this,tagName:"IFrameEditor",options:e,id:Le.name})}get editorUrl(){throw new Error("<IFrameEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set editorUrl(e){throw new Error("<IFrameEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}},je="<h2> Combination of Rules</h2>\n\n        <p>\n            Let's look at some example natural deduction proofs combining the rules introduced above. We will discuss one example together and then there are some more exercises in the LEAN editor.  \n        </p>\n        <p>\n            Example :  $P\\lor (Q \\land R)\\vdash (P\\lor Q) \\land (P \\lor R)$\n            $$\\infer{\\land Intro}{ (P\\lor Q) \\land (P \\lor R)} \n            {\\infer{\\lor Elim}{P \\lor Q}{P\\lor (Q \\land R) &\n            \\infer{\\lor Intro}{P\\lor Q}{P}& \\infer{\\lor Intro}{P\\lor Q}{\\infer{\\land Elim}{Q}{Q\\land R}}} & \n            \\infer{\\lor Elim}{P\\lor R}{P\\lor (Q \\land R) & \\infer{\\lor Intro}{P\\lor R}{P}& \\infer{\\lor Intro}{P\\lor R}{\\infer{\\land Elim}{R}{Q\\land R}}}} $$   \n        </p>\n",Se='<h2> Conditional</h2>\n<p> The inference rules for the classical material conditional in propositional logic are the following: \n    $$\\infer{\\rightarrow Intro}{P\\rightarrow Q} {\\underset{Q}{\\overset{[P]}{\\vdots} }}$$ \n\n    $$\\infer{\\rightarrow Elim}{Q} {P\\rightarrow Q&P}$$\n</p>\n<p> Their LEAN implementation functions in p parallel way. First, let\'s look at the elimination of the conditional, the rule of Modus Ponens. \n    The rule goes as follows, given two assumptions $(h1: P \\rightarrow Q)$ $(h2: P)$ you can deduce Q. In LEAN this is simply written as: \n     <h4 style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">h1</span> h2\n    </pre></h4> \n    The introduction of the conditional is slightly more complex. By the introduction of the conditional, one discharges the assumption of the antecedent. In our case the assumption is $P$. \n    The discharged assumption is indicated by the square brackets [ ] in the rule of propositional logic. In LEAN this discharging of the assumption works via a so called tactic. The tactic is called fun and may be familiar to you from $\\lambda$ calculus. It simply works like an assumption:  </p>\n <p>\n<h4>fun h: Antecedent +=> Consequent</h4>\n    <p>\n    The h: stands for hypothesis, you designate the antecedent as an hypothesis.  You can define more complex statements in the antecedent. But importantly, with the assumption of the antecedent, you prove the consequent. </p>\n    Here are three examples of natural deduction proofs involving the rules for the conditional. \n    See the code editor for their LEAN implementation.\n   </par>\n   <par>\n    Example 1: $P \\rightarrow Q, Q\\rightarrow R, P \\vdash R$\n\n    $$\\infer{\\rightarrow Elim}{R}{Q\\rightarrow R &\\infer{\\rightarrow Elim}{Q}{P\\rightarrow Q & P}}$$\n\n    Example 2: $\\vdash P \\rightarrow P \\land P$\n\n    $$\\infer{\\rightarrow Intro}{P\\rightarrow P \\land P}{\\infer=[\\land Intro]{P\\land P}{[P] & {[P]}}}$$\n\n    Example 3: $P\\rightarrow Q, Q\\rightarrow R \\vdash P \\rightarrow R$\n    $$\\infer{\\rightarrow Intro}{P\\rightarrow R}{\\infer{\\rightarrow Elim} {R}{Q \\rightarrow R & \\infer{\\rightarrow Elim}{Q} {P\\rightarrow Q & [P]}}}$$ \n</p>\n<p>\n    Now you can test your understanding in the exercises in the LEAN editor and replace the "sorry" placeholders with your deductions.\n</p>\n',Fe='<h2>Conjunction</h2>\n        <p> The well-known rules for conjunction in propositional logic are the following:\n            $$\\infer{\\land Intro}{P\\land Q}{P&Q}$$ \n            $$\\infer{\\land Elim} {P} {P\\land Q}$$ \n            $$\\infer{\\land Elim} {Q} {P\\land Q}$$ </p> \n\n    In the programming language LEAN, the rules function similarly. For example, in the LEAN syntax you write:\n<h4 style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">And</span>.right h\n</pre></h4>\n    This extracts from the hypothesis h: $P \\land Q$ the right conjunct P.\n\n    Similarly, to get the left conjunct, you can use the following syntax in LEAN\n\n<h4 style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">And</span>.left h\n </pre></h4>\n\n    We have to be specific in LEAN, indicating exactly which conjunct we want to extract. \n    For the introduction of a conjunction of P and Q we write:\n\n<h4 style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">And</span>.intro <span style="color: #BB0066; font-weight: bold">P</span> <span style="color: #BB0066; font-weight: bold">Q</span>\n</pre></h4>\n\n<h4 style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">And</span>.intro hA hB\n</pre></h4>\n\n   The latter formulation works for hypothesis hA, hB respectively. \n</p>\n<p>\n   Next let us consider an example natural deduction proof involving both the introduction and the elimation rules for conjunction: \n       </p>\n         <p>\n        Example 1: $Q \\land P \\vdash P \\land Q$\n         $$\\infer{\\land Intro}\n             {P\\land Q} \n               {\\infer{\\land Elim} {P} {Q \\land P}\n               & \\infer{\\land Elim}{Q} {Q \\land P}}\n                  $$\n        </p>\n    This proof is also done in LEAN; as you can see in the code editor on the page. \n    This should give you an example to then continue the exercises in LEAN using the syntax for conjunction we just introduced. There are easier and harder exercises. You just remove the "sorry" placeholer and write your proof. You should be able to see LEAN messages regarding your proof. \n\n    <p> \n        Lastly, there is one helpful tool. When you write down natural deduction proofs on paper, you might want to use intermediary steps, similarly online. See for example the last hard exercise in the LEAN editor. It could be helpful to prove R as an intermediary goal there.\n        LEAN allows you to do this by writing \n        <h4 style="background: #ffffff; text-align: center;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #BB0066; font-weight: bold"></span><span style="color: #333333"></span>  <span style="color: #000000; font-weight: bold">show R </span><span style="color: #008800; font-weight: bold">from And.right (And.right h)</span>\n        </pre></h4>\n        \n    </p>\n\n',Ie='<h2>Disjunction</h2>\n        <p> \n            The rules for disjunction in propositional logic are the following: \n            $$\\infer{\\lor Intro} {P\\lor Q} {P}$$   $$\\infer{\\lor Intro} {P\\lor Q} {Q}$$ \n            $$\\infer{\\lor Elim} {R} {P \\lor Q & {\\underset{R}{\\overset{[P]}{\\vdots}}} & {\\underset{R}{\\overset{[Q]}{\\vdots}}}}$$\n        </p>\n        <p> The syntax of the rules in LEAN is again similar. For the introduction of the disjunction, you can use one of the following. Note in LEAN the order of the disjuncts matters.\n            <h4 style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">Or.intro_left</span> P  Q \n            </pre></h4>\n            <h4 style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">Or.intro_right</span> Q  P \n            </pre></h4> \n            The syntax for the disjunction elimination rule is p bit more complicated. You need to show that R follows from both P and Q independently to be able to eliminate the disjunction.\n            This is done using the same tactic we saw with the conditional "fun". So we write \n            <h4>Or.elim  P $\\lor$ Q ( fun h1: P +=> R) ( fun h1: Q +=> R) </h4>\n           \n        <p>\n            Now look at an example natural deduction proof using the rules for conjunction and its implementation in LEAN. \n            Example 1: $P\\lor Q \\vdash P \\lor (Q \\lor R)$\n            $$\\infer{\\lor Elim}{P\\lor (Q \\lor R)}{P\\lor Q &\\infer{\\lor Intro}{P\\lor (Q\\lor R)}{[P]} & \\infer{\\lor Intro}{P\\lor (Q\\lor R)}{\\infer{\\lor Intro}{Q\\lor R}{[Q]}}} $$\n            And there are again some exercises for you to complete in LEAN in the editor. \n        </p>\n    \n',Ue='<html>\n  <head>\n    <link rel="stylesheet" href="introduction.css">\n    \x3c!-- Link to an external CSS file --\x3e\n    <link rel="stylesheet" href="style.css">\n    \x3c!-- Load MathJax script --\x3e\n    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"><\/script>\n    <script type="text/javascript">\n      MathJax.Hub.Config({\n      tex2jax: {\n      inlineMath: [ [\'$\',\'$\'], [\'\\\\(\',\'\\\\)\'] ]\n          }\n        });\n    <\/script>\n    \n  </head>\n\n  <div>\n        \x3c!-- Use section element for each section --\x3e\n        <article class="lean_intro_body">\n          \x3c!-- Use article element for main content --\x3e\n          <h2> Introduction To LEAN </h2>\n          <p> \n              This section gives you the basics of using LEAN for logic exercises.  \n            We start by introducing the syntax of LEAN so that you can write the logical connectives.   \n            You will have already seen the LEAN editor on the right. This is where you can write LEAN. \n             See the table below for instructions on how to write for example the connectives in LEAN:\n          </p>\n\n        <article class="syntax_para">\n            <h3> Using Connectives in LEAN</h3>\n            <table class="syntax_table">\n              <colgroup>\n                <col style="border:18%">\n                <col style="width: 30%">\n                <col style="width: 52%">\n              </colgroup>\n              <tbody>\n                <tr class="row-odd">\n                  <td>\n                    <p><u>name</u> </p>\n                    </td>\n                  <td>\n                    <p><u>in English</u></p>\n                    </td>\n                  <td>\n                    <p><u>symbol used</u></p>\n                  </td>\n                  <td>\n                    <p><u>LEAN syntax</u></p>\n                  </td>\n                </tr>\n                <tr class="row-even">\n                  <td>\n                    <p>disjunction</p>\n                  </td>\n                  <td>\n                    <p>or </p>\n                  </td>\n                  <td>\n                    <p>∨</p>\n                    </td>\n                  <td>\n                    <p>\\or</p>\n                    </td>\n                </tr>\n                <tr class="row-odd">\n                  <td>\n                    <p>conjunction</p>\n                  </td>\n                  <td>\n                    <p> and </p>\n                  </td>\n                  <td>\n                    <p>∧</p>\n                    </td>\n                  <td>\n                    <p>\\and</p>\n                    </td>\n                  </tr>\n                <tr class="row-even">\n                  <td>\n                    <p>negation </p>\n                  </td>\n                  <td>\n                    <p>it is not the case that </p>\n                  </td>\n                  <td>\n                    <p>￢</p>\n                    </td>\n                  <td>\n                    <p>\\not, \\neg</p>\n                    </td>\n                </tr>\n                <tr class="row-even">\n                  <td>\n                      <p>arrow (conditional)</p>\n                    </td>\n                  <td>\n                    <p>if ... then </p>\n                  </td>\n                  <td>\n                    <p>→</p>\n                    </td>\n                  <td>\n                    <p>\\to, \\r, \\imp </p>\n                    </td>\n                <tr class="row-odd">\n                  <td>\n                    <p>double arrow (biconditional)</p>\n                  </td>\n                  <td>\n                    <p>if and only if </p>\n                  </td>\n                  <td>\n                    <p>↔︎</p>\n                    </td>\n                  <td>\n                    <p>\\iff, \\lr</p>\n                    </td>\n                </tr>\n              </tbody>\n            </table>\n        </article>\n      </section>\n    </div>\n    </p>\n    <p>\n    You may have noticed the following line at the top of the LEAN editor window:\n        <h4 style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">variable</span>(P Q R: Prop)\n        </pre></h4>\n    It specifies propositions in the language. In the Logic Manual, Halbach calls these sentence letters. Now a proposition is a sentence letter which has a truth value. \n    A semantic structure assigns a truth value to exactly every sentence letter of the language. Hence, we can understand the sentence letters as propositions here. The semantics of propositional logic are discussed in detail in the next section.\n    <p>\n    By definition 2.2 in the Logic Manual, we know for sentence letters P,Q that binary connectives $\\land, \\lor, \\rightarrow, \\leftrightarrow$ produce new sentences $P\\land Q, P\\lor Q, P\\rightarrow Q, P \\leftrightarrow Q$.\n    Similarly, for a sentence $P$ and negation, $\\neg P$ is also a sentence.\n    You can confirm this by clicking on the statements in the code editor. We defined $P, Q$ as propositions and hence LEAN returns that $P \\lor Q$, $P\\land Q$ etc. are also propositions.\n    </p>\n    <h3>Brackets</h3>\n    <p>\n    The logic manual gives three conventions concerning brackets for compound sentences in section $2.3$. LEAN evaluates sentences from left to right and will assume brackets from left to right if you do not specify them. \n    For example, if you input $P \\land \\neg P \\lor R$, LEAN will evaluate $(P \\land \\neg P) \\lor R$. This example will also be discussed in more detail in the next section.\n    \n    </p>\n</body>\n</html>\n',Be='<h2> Negation</h2>\n        <p>\n            The rules for negation in propositional logic are well known to you.  \n            $$\\infer{\\neg Intro} {\\neg P} { {\\underset{Q}{\\overset{[P]}{\\vdots}} &  {\\underset{\\neg Q}{\\overset{[P]}{\\vdots}}}}}$$  $$\\infer{\\neg Elim } { P}  {\\underset{Q}{\\overset{[\\neg P]}{\\vdots}} &  {\\underset{\\neg Q}{\\overset{[\\neg P]}{\\vdots}}}}$$\n        </p>\n        <p>\n            This works differently in LEAN. Negation $\\neg P$ is here defined as $A \\rightarrow \\bot$, where $\\bot$ is a contradiction such as $ 0\\neq 0 $ for example.\n            There are two main tactics for negation in LEAN. The first one is similar to negation introduction. If you want to prove $\\neg P$ then you assume $P$ and show that it leads to a contradiction. \n            This assumption is constructed similarly to the conditional and disjunctive rules above. So under some assumption you proof a contradiction (a False in LEAN). Then you get the desired result $\\neg P$. It is written as follows:\n            <h4>fun h: P +=> show False from $\\neg Q \\quad Q$</h4>\n           \n            Note that the order matters here, if you want to show False from $Q$ and $\\neg Q$, you must state the negated statement first. \n            \n        </p>\n        <p></p>\n            The second tactic involving negation used in LEAN is the so called Ex falso quodlibet principle that anything can be derived from p contradiction. In LEAN this is done by p new tactic: absurd. \n            So suppose you are given some contradictory assumptions such as h1: $ P$ and h2: $\\neg A$. Then you can prove any claim $Q$ simply by stating \n            <h4 style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">absurd</span> h2 h1\n            </pre></h4>\n            Again here the order matters. \n        </p>\n        <p>\n            Let\'s look at some example derivations both in propositional logic and LEAN. Again, you can find more exercises in the editor. \n            Example 1: $P\\rightarrow Q, \\neg Q\\vdash \\neg P$\n            $$\\infer{\\neg Intro}{\\neg P}{\\infer{\\rightarrow Elim}{Q}{P\\rightarrow Q & [P]} & \\neg Q}$$\n            Example 2: $P\\land Q, \\neg P\\vdash R$\n            $$\\infer=[  ]{R}{\\infer{\\land Elim}{P}{P\\land Q}&\\neg P}$$\n        </p>\n',Te="<h2>\n    Semantics of Propositional Logic\n    </h2>\n    <div>\n       <p>\n         This section will discuss the semantics of Propositional Logic, following Chapter 5 of the Logic Manual. \n         <i>Please do not consider the first 2 lines of the code editor, this defines the interpret function in LEAN. </i>\n        </p> \n        <p>\n        Semantic structures assign truth values to sentences in the language. We construct here p toy model and declare sentences P, Q as false and R as true.\n        Now following the definition of satisfaction (Def 5.2) you can evaluate the truth value of compound sentences. \n        Instead of truth tables, LEAN automatically completes this interpretation. If you click on the #eval statements, you can see 'true' or 'false'. \n        </p>\n        <p>\n        You have to be precise with your brackets in LEAN. First, because we evaluate the <i>interpret</i> function, we need to put brackets around the sentences. If you use multiple connectives and don't specify the brackets, LEAN <b> automatically</b> adds brackets from left to right. \n        The first example shows this: if you input $P \\land \\neg P \\lor R$, LEAN will evaluate $(P \\land \\neg P) \\lor R$. \n        </p>\n        <h3>Countermodels</h3>\n        <p>\n        We just looked at an example model in the previous example. Now we say that a sentence $\\phi$ is logically implied by a set of sentences $\\Gamma$ (formally $\\Gamma \\vDash \\phi$) if there is no counterexample to the argument. \n        The next exercise is for you to define the values of P, Q and R such that the statements in the code editor are false. So you provide a countermodel. \n        You have to remove the -- lines in your code editor for your answer to be processed. \n      </p>\n        <p>\n        Test your own examples! You can define your own assigments and evaluate more complex expression. \n        </p>\n     \n    \n    \n    ",We='<html>\n<body>\n    <div>\n          <h2>LEAN and the Logic Manual</h2>\n        </div>\n\n    <p>  LEAN is an <i>open source</i> programming language and a theorem prover. This resource introduces LEAN for Propositional Logic for users of the <i>Logic Manual</i> by Volker Halbach. It has been adapted for use at King\'s College London by Jordan Brown, Connor Molinski, Elena Wüllhorst, Carlo Nicolai.</p> \n\n\n     <footer>\n        <b>Acknowledgements</b>: for the content and some notational choices, the project is based on the <a href="https://users.ox.ac.uk/~logicman/"><i>Logic Manual</i></a>\n        by Volker Halbach, Oxford University Press, 2010; for implementation in LEAN, we relied on \n        <a href="https://leanprover.github.io/logic_and_proof/index.html"><i>Logic and Proof</i></a> by Jeremy Avigad, Robert Y. Lewis, and Floris van Doorn, and the LEAN 4 webeditor. \n    </footer>\n    </div>\n\n    </html>',Me="https://live.lean-lang.org/#code=variable%20(P%20Q%20R%3A%20Prop)%20%0A%0A--%20Combinations%20of%20rules%0Aexample%20(h%3AP%E2%88%A8%20(Q%E2%88%A7%20R))%3A(P%E2%88%A8%20Q)%20%E2%88%A7%20(P%20%E2%88%A8%20R)%3A%3D%0A%20%20And.intro%20%0A%20%20(Or.elim%20h%20%0A%20%20(fun%20h1%3AP%20%3D%3E%20Or.intro_left%20Q%20h1)%0A%20%20(fun%20h2%3AQ%E2%88%A7R%20%3D%3E%20Or.intro_right%20P%20(And.left%20h2)))%0A%20%20(Or.elim%20h%20%0A%20%20(fun%20h1%3AP%20%3D%3E%20Or.intro_left%20R%20h1)%0A%20%20(fun%20h2%3AQ%E2%88%A7R%20%3D%3E%20Or.intro_right%20P%20(And.right%20h2)))%0A%0Aexample%20(h%3A%20(P%E2%86%92%20Q)%E2%86%92%20Q)%3A%20%C2%ACB%20%E2%86%92%20P%3A%3D%0A%20%20sorry%20%0A%0Aexample%20%3A%20%C2%AC%20(P%E2%88%A7B)%20%E2%86%92%20%20(%C2%AC%20P%20%E2%88%A8%20%C2%AC%20Q)%3A%3D%0A%20%20sorry%0A%0Aexample%3A%20%20(%C2%AC%20P%20%E2%88%A8%20%C2%AC%20Q)%20%E2%86%92%20%20%C2%AC%20(P%E2%88%A7B)%3A%3D%0A%20%20sorry%20%0A%0Aexample%20(h1%3A%20P%20%E2%86%92%20Q)(h2%3A%20P%20%E2%88%A7%20%C2%AC%20Q)%3A%20R%3A%3D%0A%20%20sorry%0A%20%20%0A%0A",Oe="https://live.lean-lang.org/#code=variable%20(P%20Q%20R%20%3A%20Prop)%20%0A%0A--%20Conditional%3A%20Example%20(See%20website)%0Aexample%20(h1%3A%20P%20%E2%86%92%20Q)(h2%3A%20Q%E2%86%92%20R)%20(h3%3A%20P)%3A%20R%3A%3D%0A%20%20h2%20(show%20Q%20from%20h1%20h3)%0A%0Aexample%3A%20%20P%20%E2%86%92%20P%20%E2%88%A7%20P%3A%3D%0A%20%20%20fun%20h%3A%20P%20%3D%3E%20%20And.intro%20h%20h%20%0A%0Aexample%20(h1%3A%20P%20%E2%86%92%20Q%20)(h2%3A%20Q%E2%86%92%20R)%3A%20P%20%E2%86%92%20R%3A%3D%0A%20(fun%20h%3A%20P%3D%3E%0A%20%20show%20R%20from%20h2%20(show%20Q%20from%20h1%20h))%0A%0A--%20easy%20Exercises%20%0Aexample%20(h1%3A%20P%E2%86%92%20Q)(h2%3A%20P)%3A%20Q%3A%3D%0Asorry%20%0A%0Aexample%3A%20P%20%E2%86%92%20Q%3A%3D%0Asorry%20%0A%0Aexample%3A%20P%20%E2%86%92%20Q%20%E2%86%92%20P%3A%3D%0Asorry%20%0A%0A--%20harder%20Exercises%20%0Aexample%20(h1%3A%20(P%E2%86%92%20Q)%E2%86%92%20P%20)%3A%20Q%E2%86%92%20P%3A%3D%0Asorry%0A%0Aexample%20(h%3A%20P%E2%88%A7%20Q)%3A%20P%20%E2%86%92%20Q%3A%3D%0Asorry%20%0A%0A\n",Je="https://live.lean-lang.org/#code=variable%20(P%20Q%20R%3A%20Prop)%20%0A--%20Conjunction%3A%20Example%20(See%20Website)%0Aexample%20(h1%20%3A%20P%20%E2%88%A7%20Q)%3A%20Q%20%E2%88%A7%20P%20%3A%3D%0A%20%20And.intro%20(And.right%20h1)%20(And.left%20h1)%0A%0A--%20easy%20Exercises%20%0Aexample%20(h%3A%20P%20%E2%88%A7B)%3A%20P%3A%3D%0Asorry%0A%0Aexample%20(h%3A%20P%20%E2%88%A7B)%3A%20Q%3A%3D%0Asorry%20%20%0A%0Aexample%20(h%3A%20P%20%E2%88%A7B)%3A%20P%20%E2%88%A7%20Q%20%E2%88%A7%20P%3A%3D%0Asorry%20%0A%0A--%20harder%20Exercises%20%0Aexample%20(h1%3A%20P%20%E2%88%A7%20Q)(h2%3A%20R)%3A%20P%20%E2%88%A7%20Q%20%E2%88%A7%20R%3A%3D%0Asorry%20%0A%0Aexample%20(h%3A%20P%20%E2%88%A7%20(Q%20%E2%88%A7%20R))%3A%20(R%20%E2%88%A7%20P)%20%E2%88%A7%20Q%3A%3D%0Asorry%20%20%0A%0A%0A",Ze="https://live.lean-lang.org/#code=variable%20(P%20Q%20R%3A%20Prop)%20%0A%0A--%20Disjunction%3A%20Example%20(See%20Website)%0Aexample%20(h%3AP%20%E2%88%A8%20Q)%3AP%20%E2%88%A8%20(Q%20%E2%88%A8%20R)%3A%3D%0A%20%20Or.elim%20h%0A%20%20(fun%20h1%3A%20P%20%3D%3E%20%0A%20%20%20%20%20%20show%20P%20%E2%88%A8%20(Q%20%E2%88%A8%20R)%20from%20Or.intro_left%20(Q%20%E2%88%A8%20R)%20h1)%0A%20%20(fun%20h2%3AQ%20%3D%3E%20%0A%20%20%20%20show%20P%20%E2%88%A8%20(Q%20%E2%88%A8%20R)%20from%20Or.intro_right%20P%20(Or.intro_left%20R%20h2))%0A%0A%0A--%20easy%20Exercises%0Aexample%20(h%3AP)%3AP%20%E2%88%A8%20Q%3A%3D%0Asorry%0A%0Aexample%20(h%3AP%20%E2%88%A8%20Q)%3A%20Q%20%E2%88%A8%20P%3A%3D%0Asorry%0A%0Aexample%20(h%3A%20(P%20%E2%86%92%20Q)%20%E2%88%A8%20Q)%3A%20P%20%E2%86%92%20Q%20%3A%3D%0Asorry%0A%0A--%20harder%20Exercises%0Aexample%20(h%3A%20(P%20%E2%88%A8%20Q)%20%E2%88%A7%20(P%20%E2%88%A8%20R))%3A%20P%20%E2%88%A8%20(Q%20%E2%88%A8%20R)%3A%3D%0Asorry%20%0A%0A",ze="https://live.lean-lang.org/#code=variable%20(P%20Q%3A%20Prop)%20%0A%0A%23check%20P%20%E2%88%A8%20Q%0A%0A%23check%20P%20%E2%88%A7%20Q%0A%0A%23check%20P%20%E2%86%92%20Q%0A%0A%23check%20P%20%E2%86%94%20Q%0A%0A%23check%20%C2%AC%20P",Xe="https://live.lean-lang.org/#code=variable%20(P%20%20Q%3A%20Prop)%20%0A%0A--%20Negation%3A%20Example%20(See%20Website)%0Aexample%20(h1%3AP%20%20%E2%86%92%20Q)%20(h2%3A%20%C2%AC%20Q)%3A%20%C2%AC%20P%20%3A%3D%0A%20%20fun%20h%3A%20P%20%3D%3E%0A%20%20show%20False%20from%20h2%20(h1%20h)%0A%0Aexample%20(h1%3A%20P%20%20%E2%88%A7%20Q)(h2%3A%20%C2%AC%20P%20)%3A%20Q%20%3A%3D%0A%20%20absurd%20(And.left%20h1)%20h2%0A%0A--easy%20Exercises%0Aexample%20(h1%3AP%20)%3A%20%C2%AC%20%C2%AC%20P%20%3A%3D%0Asorry%20%0A%0Aexample%20(h1%3A%20P%20)%20(h2%3A%20%C2%AC%20P%20)%3A%20Q%3A%3D%0Asorry%0A%0Aexample%20(h1%3A%20P%20%20%E2%88%A7%20%C2%AC%20P%20)%3A%20Q%3A%3D%0Asorry%20%0A%0Aexample%20(h1%3A%20P%20%20%E2%86%92%20%C2%AC%20P%20)%3A%20%C2%AC%20P%20%3A%3D%0Asorry%20%0A%0A--harder%20Exercises%0Aexample%20(h1%3A%20P%20%20%E2%86%92%20Q)%20(h2%3A%20P%20%20%E2%88%A7%20%C2%AC%20Q)%3A%20C%3A%3D%0Asorry%20%0A%0Aexample%20(h%3A%20%C2%AC%20P%20%20%E2%88%A8%20%C2%AC%20Q)%3A%20%C2%AC%20(P%20%20%E2%88%A7%20Q)%3A%3D%0Asorry%20%0A",Ye="https://live.lean-lang.org/#code=def%20interpret%20(p%3AProp)%20%5BDecidable%20p%5D%3A%20String%3A%3D%0Aif%20p%20then%20%22true%22%20else%20%22false%22%0A%0Adef%20P%20%3A%3D%20false%0Adef%20Q%20%3A%3D%20false%20%0Adef%20R%20%3A%3D%20true%0A%0A%23eval%20interpret%20(P%20%E2%88%A7%20%C2%AC%20P%20%E2%88%A8%20R)%0A%23eval%20interpret%20((P%20%E2%88%A7%20%C2%AC%20P)%20%E2%88%A8%20R)%0A%23eval%20interpret%20(%20P%20%E2%88%A7%20(%C2%AC%20P%20%E2%88%A8%20R))%0A%0A%23eval%20interpret%20(P%20%E2%88%A8%20%C2%AC%20Q)%0A%23eval%20interpret%20(P%20%E2%88%A7%20(%C2%AC%20Q%20%E2%88%A8%20%C2%AC%20R))%0A%0A%0A--def%20P%3A%3D%0A--def%20Q%3A%3D%0A--def%20R%3A%3D%0A%0A--Provide%20P%20counterexample%20%0A--by%20defining%20the%20truthvalue%20of%20P%20and%20Q%0A--%23eval%20interpret%20(P%E2%88%A8Q)%0A--%23eval%20interpret%20(P%E2%88%A7%20%C2%ACP)%0A%0A--Can%20you%20provide%20P%20counterexample%20for%20the%20statements%3F%20%0A--(Tautologies)%0A--%23eval%20interpret%20((P%E2%88%A8%20%C2%ACP)%E2%86%92%20(Q%E2%88%A8%C2%AC%20Q))%0A--%23eval%20interpret%20(((P%E2%86%92%20%C2%ACQ)%E2%88%A7%20Q)%E2%86%92%20%C2%ACP)%0A",Ve="https://live.lean-lang.org/",{console:qe}=e,Ge="src/App.svelte";function He(e){s(e,"svelte-1kdsmws","@media(min-width: 640px){main.svelte-1kdsmws{max-width:none}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXBwLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFpRkkseUJBQ0ksb0JBQ0MsY0FDRCxDQUNKIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkFwcC5zdmVsdGUiXX0= */")}function Ke(e){let t,n,o;function r(t){e[3](t)}let i={ref:"document"};void 0!==e[0]&&(i.page=e[0]),t=new ye({props:i,$$inline:!0}),N.push((()=>Z(t,"page",r)));const s={c:function(){z(t.$$.fragment)},m:function(e,n){X(t,e,n),o=!0},p:function(e,o){const r={};!n&&1&o&&(n=!0,r.page=e[0],S((()=>n=!1))),t.$set(r)},i:function(e){o||(O(t.$$.fragment,e),o=!0)},o:function(e){J(t.$$.fragment,e),o=!1},d:function(e){Y(t,e)}};return K("SvelteRegisterBlock",{block:s,id:Ke.name,type:"key",source:"(43:4) {#key selectedDocument}",ctx:e}),s}function et(e){let t,n,o,r,i,s,a,l,d=e[0];n=new Pe({$$inline:!0}),n.$on("documentSelection",e[2]);let u=Ke(e);function p(t){e[4](t)}let f={};void 0!==e[1]&&(f.editorUrl=e[1]),s=new _e({props:f,$$inline:!0}),N.push((()=>Z(s,"editorUrl",p)));const A={c:function(){t=c("body"),z(n.$$.fragment),o=h(),r=c("main"),u.c(),i=h(),z(s.$$.fragment),re(r,"class","svelte-1kdsmws"),$(r,Ge,47,2,2109),$(t,Ge,45,0,2038)},l:function(e){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(e,a){te(e,t,a),X(n,t,null),ee(t,o),ee(t,r),u.m(r,null),ee(r,i),X(s,r,null),l=!0},p:function(e,[t]){1&t&&b(d,d=e[0])?(W={r:0,c:[],p:W},J(u,1,1,m),W.r||w(W.c),W=W.p,u=Ke(e),u.c(),O(u,1),u.m(r,i)):u.p(e,t);const n={};!a&&2&t&&(a=!0,n.editorUrl=e[1],S((()=>a=!1))),s.$set(n)},i:function(e){l||(O(n.$$.fragment,e),O(u),O(s.$$.fragment,e),l=!0)},o:function(e){J(n.$$.fragment,e),J(u),J(s.$$.fragment,e),l=!1},d:function(e){e&&ne(t),Y(n),u.d(e),Y(s)}};return K("SvelteRegisterBlock",{block:A,id:et.name,type:"component",source:"",ctx:e}),A}function tt(e,t,n){let{$$slots:o={},$$scope:r}=t;ie("App",o,[]);let i=new Map;i.set("CombinedRules",[je,Me]),i.set("Conditional",[Se,Oe]),i.set("Conjunction",[Fe,Je]),i.set("Disjunction",[Ie,Ze]),i.set("Syntax",[Ue,ze]),i.set("Semantics",[Te,Ye]),i.set("Negation",[Be,Xe]),i.set("Welcome",[We,Ve]);let s=We,a=Ve;function l(e){const t=i.get(e.detail.document);n(0,s=t[0]),n(1,a=t[1]),console.log("caught event in App.svelte: "+s)}const c=[];return Object.keys(t).forEach((e=>{~c.indexOf(e)||"$$"===e.slice(0,2)||"slot"===e||qe.warn(`<App> was created with unknown prop '${e}'`)})),e.$capture_state=()=>({Document:ye,Sidebar:Pe,IFrameEditor:_e,CombinedRules:je,Conditional:Se,Conjunction:Fe,Disjunction:Ie,Syntax:Ue,Negation:Be,Semantics:Te,Welcome:We,CombinedRulesT:Me,ConditionalT:Oe,ConjunctionT:Je,DisjunctionT:Ze,SyntaxT:ze,NegationT:Xe,SemanticsT:Ye,WelcomeT:Ve,map:i,selectedDocument:s,editorText:a,handlePageChange:l}),e.$inject_state=e=>{"map"in e&&(i=e.map),"selectedDocument"in e&&n(0,s=e.selectedDocument),"editorText"in e&&n(1,a=e.editorText)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),[s,a,l,function(e){s=e,n(0,s)},function(e){a=e,n(1,a)}]}new class extends se{constructor(e){super(e),V(this,e,tt,et,b,{},He),K("SvelteRegisterComponent",{component:this,tagName:"App",options:e,id:et.name})}}({target:document.body,props:{name:"world"}})})();
//# sourceMappingURL=bundle.js.map